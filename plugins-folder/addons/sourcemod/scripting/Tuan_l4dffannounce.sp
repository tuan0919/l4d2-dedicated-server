/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1
#pragma newdecls required

#include <sourcemod>
#include <sdktools>
#include <sdkhooks>
#include <colors>
#define PLUGIN_VERSION			"1.8"

public Plugin myinfo = 
{
	name = "L4D FF Announce Plugin",
	author = "Frustian & HarryPotter",
	description = "Display Friendly Fire Announcements",
	version = PLUGIN_VERSION,
	url = "https://steamcommunity.com/profiles/76561198026784913"
}

#define MAXENTITIES 2048

int DamageCache[MAXPLAYERS+1][MAXPLAYERS+1]; //Used to temporarily store Friendly Fire Damage between teammates
Handle FFTimer[MAXPLAYERS+1]; //Used to be able to disable the FF timer when they do more FF

public APLRes AskPluginLoad2(Handle myself, bool late, char[] error, int err_max) 
{
	EngineVersion test = GetEngineVersion();
	
	if( test != Engine_Left4Dead2 && test != Engine_Left4Dead) 
	{
		strcopy(error, err_max, "Plugin only supports Left 4 Dead 1 & 2.");
		return APLRes_SilentFailure;
	}

	return APLRes_Success; 
}

public void OnPluginStart()
{
	HookEvent("player_hurt_concise", Event_HurtConcise, EventHookMode_Post);
	HookEvent("player_incapacitated_start", Event_IncapacitatedStart);
	HookEvent("round_end",				Event_RoundEnd,		EventHookMode_PostNoCopy); //trigger twice in versus mode, one when all survivors wipe out or make it to saferom, one when first round ends (second round_start begins).
	HookEvent("map_transition", 		Event_RoundEnd,		EventHookMode_PostNoCopy); //all survivors make it to saferoom, and server is about to change next level in coop mode (does not trigger round_end) 
	HookEvent("mission_lost", 			Event_RoundEnd,		EventHookMode_PostNoCopy); //all survivors wipe out in coop mode (also triggers round_end)
	HookEvent("finale_vehicle_leaving", Event_RoundEnd,		EventHookMode_PostNoCopy); //final map final rescue vehicle leaving  (does not trigger round_end)
}

public void OnMapEnd()
{
	ResetTimer();
}

void Event_RoundEnd(Event event, const char[] name, bool dontBroadcast) 
{
	ResetTimer();
}

void Event_HurtConcise(Event event, const char[] name, bool dontBroadcast) 
{
	int attacker = event.GetInt("attackerentid");
	int victim = GetClientOfUserId(event.GetInt("userid"));
	if (attacker == victim ||
	attacker > MaxClients || 
	attacker < 1 || 
	!IsClientInGame(attacker) || 
	IsFakeClient(attacker) || 
	GetClientTeam(attacker) != 2 || 
	!IsClientInGame(victim) || 
	GetClientTeam(victim) != 2)
		return;  
	
	int damage = event.GetInt("dmg_health");
	if (FFTimer[attacker] != null)  //If the player is already friendly firing teammates, resets the announce timer and adds to the damage
	{
		DamageCache[attacker][victim] += damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
	}
	else //If it's the first friendly fire by that player, it will start the announce timer and store the damage done.
	{
		DamageCache[attacker][victim] = damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
		for (int i = 1; i <= MaxClients; i++)
		{
			if (i != attacker && i != victim)
			{
				DamageCache[attacker][i] = 0;
			}
		}
	}
}

void Event_IncapacitatedStart(Event event, const char[] name, bool dontBroadcast) 
{
	int victim = GetClientOfUserId(event.GetInt("userid"));
	int attacker = GetClientOfUserId(event.GetInt("attacker"));

	if ( attacker == victim ||
	attacker > MaxClients || 
	attacker < 1 || 
	!IsClientInGame(attacker) || 
	IsFakeClient(attacker) || 
	GetClientTeam(attacker) != 2 || 
	!IsClientInGame(victim) || 
	GetClientTeam(victim) != 2)
		return;  

	int damage = GetClientHealth(victim) + RoundToFloor(GetTempHealth(victim));
	if (FFTimer[attacker] != null)  //If the player is already friendly firing teammates, resets the announce timer and adds to the damage
	{
		DamageCache[attacker][victim] += damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
	}
	else //If it's the first friendly fire by that player, it will start the announce timer and store the damage done.
	{
		DamageCache[attacker][victim] = damage;
		delete FFTimer[attacker];
		FFTimer[attacker] = CreateTimer(1.0, AnnounceFF, attacker);
		for (int i = 1; i <= MaxClients; i++)
		{
			if (i != attacker && i != victim)
			{
				DamageCache[attacker][i] = 0;
			}
		}
	}
}

Action AnnounceFF(Handle timer, int attackerc) //Called if the attacker did not friendly fire recently, and announces all FF they did
{
	char victim[128];
	char attacker[128];

	if (IsClientInGame(attackerc) && !IsFakeClient(attackerc))
		GetClientName(attackerc, attacker, sizeof(attacker));
	else
		attacker = "Disconnected Player";

	for (int i = 1; i <= MaxClients; i++)
	{
		if (DamageCache[attackerc][i] != 0 && attackerc != i)
		{
			if (IsClientInGame(i))
			{
				GetClientName(i, victim, sizeof(victim));
				if (IsClientInGame(attackerc) && !IsFakeClient(attackerc))
					CPrintToChat(attackerc, "{default}You did {blue}%i {olive}friendly-fire {default}on {blue}%s" , DamageCache[attackerc][i], victim);
				if (IsClientInGame(i) && !IsFakeClient(i))
					CPrintToChat(i, "{blue}%N {default} did {blue}%i {olive}friendly-fire {default}on you", attacker, DamageCache[attackerc][i]);
			}
			DamageCache[attackerc][i] = 0;
		}
	}

	FFTimer[attackerc] = null;
	return Plugin_Continue;
}

void ResetTimer()
{
	for (int i = 1; i <= MaxClients; i++)
	{
		delete FFTimer[i];
	}
}

float GetTempHealth(int client)
{
	static float fCvarDecayRate = -1.0;

	if (fCvarDecayRate == -1.0)
		fCvarDecayRate = FindConVar("pain_pills_decay_rate").FloatValue;

	float fTempHealth = GetEntPropFloat(client, Prop_Send, "m_healthBuffer");
	fTempHealth -= (GetGameTime() - GetEntPropFloat(client, Prop_Send, "m_healthBufferTime")) * fCvarDecayRate;
	return fTempHealth < 0.0 ? 0.0 : fTempHealth;
}
